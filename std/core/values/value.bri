import * as runtime from "../runtime.bri";
import { source as briocheSource } from "../source.bri";
import { type Awaitable, unreachable } from "../utils.bri";
import { File } from "./file.bri";
import { Directory } from "./directory.bri";
import { Symlink } from "./symlink.bri";

export type Value = File | Directory | Symlink;

export type LazyValueSerialization<T extends Value> = runtime.WithMeta & (
  T extends File ? (
    | runtime.CompleteFile
    | runtime.LazyDownload
    | runtime.LazyProcess
    | runtime.LazyCast
    | runtime.LazyPeel
    | runtime.LazyGet
    | runtime.LazySetPermissions
    | runtime.LazyProxy) :
  T extends Directory ? (
    | runtime.LazyDirectory
    | runtime.LazyUnpack
    | runtime.LazyProcess
    | runtime.LazyCast
    | runtime.LazyMerge
    | runtime.LazyPeel
    | runtime.LazyGet
    | runtime.LazyRemove
    | runtime.LazyProxy) :
  T extends Symlink ? (
    | runtime.CompleteSymlink
    | runtime.LazyProcess
    | runtime.LazyCast
    | runtime.LazyPeel
    | runtime.LazyGet
    | runtime.LazyProxy) :
  never
);

export type Lazy<T extends Value = Value> = LazyCommon<T> & (
  [T] extends [File] ? LazyFileUtils
  : [T] extends [Directory] ? LazyDirectoryUtils
  : [T] extends [Symlink] ? LazySymlinkUtils
  : {}
);

interface LazyCommon<T extends Value> extends LazyUtils<T> {
  resolve(): Awaitable<T>;
  briocheSerialize(): Awaitable<LazyValueSerialization<T>>;
}

interface LazyUtils<T extends Value> {
  cast(to: "file"): T extends File ? Lazy<File> : never;
  cast(to: "directory"): T extends Directory ? Lazy<Directory> : never;
  cast(to: "symlink"): T extends Symlink ? Lazy<Symlink> : never;
}

interface LazyFileUtils extends LazyUtils<File> {
  withPermissions(permissions: Partial<Permissions>): Lazy<File>;
  unpack(archiveFormat: runtime.ArchiveFormat, compressionFormat?: runtime.CompressionFormat): Lazy<Directory>;
}

interface LazyDirectoryUtils extends LazyUtils<Directory> {
  get(...paths: string[]): Lazy<Value>;
  insert(path: string, value: AsyncLazy<Value>): Lazy<Directory>;
  remove(...paths: string[]): Lazy<Directory>;
  peel(depth?: number): Lazy;
}

interface LazySymlinkUtils extends LazyUtils<Symlink> {}

export interface Permissions {
  executable: boolean;
}

// export interface Lazy<T extends Value = Value> extends Resolve<T> {
//   briocheSerialize(): Awaitable<LazyValueSerialization<T>>;
//   cast(to: "file"): T extends File ? Lazy<File> : never;
//   cast(to: "directory"): T extends Directory ? Lazy<Directory> : never;
//   cast(to: "symlink"): T extends Symlink ? Lazy<Symlink> : never;
// }

export type AsyncLazy<T extends Value = Value> = Awaitable<Lazy<T>>;

export async function asyncResolve<T extends Value>(value: AsyncLazy<T>): Promise<T> {
  return (await value).resolve();
}

export async function asyncBriocheSerialize<T extends Value>(value: AsyncLazy<T>): Promise<LazyValueSerialization<T>> {
  return (await value).briocheSerialize();
}

export function briocheDeserializeAny(value: runtime.CompleteValue, source: runtime.Source | undefined): Value {
  switch (value.type) {
    case "file":
      return File.briocheDeserialize(value, source);
    case "directory":
      return Directory.briocheDeserialize(value, source);
    case "symlink":
      return Symlink.briocheDeserialize(value, source);
    default:
      return unreachable(value);
  }
}

export type LazyOptions<T extends Value> = {
  sourceDepth?: number;
} & (
  | {
    briocheSerialize?(meta: runtime.Meta): Awaitable<LazyValueSerialization<T>>;
    resolve(meta: runtime.Meta): Awaitable<T>;
  }
  | {
    briocheSerialize(meta: runtime.Meta): Awaitable<LazyValueSerialization<T>>;
    resolve?(meta: runtime.Meta): Awaitable<T>;
  }
);

export type ValueType<T extends Value> = T extends File ? "file" : T extends Directory ? "directory" : T extends Symlink ? "symlink" : never;

type CastTo = "file" | "directory" | "symlink";

type CastResult<T extends CastTo> =
  T extends "file" ? File :
  T extends "directory" ? Directory :
  T extends "symlink" ? Symlink :
  never;

export function createLazy<T extends Value>(types: ValueType<T>[], opts: LazyOptions<T>): Lazy<T> {
  const source = briocheSource({ depth: (opts.sourceDepth ?? 0) + 1 });
  const meta = { source };

  const isFile = types.some(type => type === "file");
  const isDirectory = types.some(type => type === "directory");
  const isSymlink = types.some(type => type === "symlink");

  return {
    briocheSerialize: async () => {
      if (opts.briocheSerialize) {
        return opts.briocheSerialize(meta);
      } else if (opts.resolve) {
        return (await opts.resolve(meta)).briocheSerialize();
      } else {
        throw new Error("resolve or briocheSerialize is required");
      }
    },
    resolve: async () => {
      if (opts.resolve) {
        return opts.resolve(meta);
      } else if (opts.briocheSerialize) {
        const result = await runtime.resolve(await opts.briocheSerialize(meta));
        return briocheDeserializeAny(result, source);
      } else {
        throw new Error("resolve or briocheSerialize is required");
      }
    },
    ...lazyUtils,
    ...(isFile ? lazyFileUtils : {}),
    ...(isDirectory ? lazyDirectoryUtils : {}),
    ...(isSymlink ? lazySymlinkUtils : {}),
  } as Lazy<T>;
}

export const lazyUtils = {
  cast(this: Lazy, to: CastTo) {
    return createLazy([to as any], {
      sourceDepth: 1,
      briocheSerialize: async (meta) => {
        const value = await this.briocheSerialize();
        return {
          type: "cast",
          value,
          to,
          meta,
        };
      },
    }) as any;
  }
};
export const lazyFileUtils: LazyFileUtils = {
  cast: lazyUtils.cast as LazyFileUtils["cast"],
  withPermissions(this: Lazy<File>, permissions: Partial<Permissions>): Lazy<File> {
    return createLazy(["file"], {
      sourceDepth: 1,
      briocheSerialize: async (meta) => {
        const file = await this.briocheSerialize();
        return {
          type: "set_permissions",
          file,
          executable: permissions.executable ?? null,
          meta,
        }
      },
    });
  },
  unpack(this: Lazy<File>, archiveFormat: runtime.ArchiveFormat, compressionFormat?: runtime.CompressionFormat): Lazy<Directory> {
    return createLazy(["directory"], {
      sourceDepth: 1,
      briocheSerialize: async (meta) => {
        const file = await this.briocheSerialize();
        return {
          type: "unpack",
          file,
          archive: archiveFormat,
          compression: compressionFormat,
          meta,
        }
      },
    });
  }
};

function directoryStructure(pathComponents: string[], value: runtime.LazyValue): runtime.LazyDirectory {
  const [head, ...tail] = pathComponents;
  if (head == null) {
    throw new Error("path must not be empty");
  }

  if (tail.length === 0) {
    return {
      type: "directory",
      entries: {
        [runtime.bstring(head)]: value,
      },
    };
  } else {
    return {
      type: "directory",
      entries: {
        [runtime.bstring(head)]: directoryStructure(tail, value),
      },
    };
  }
}

export const lazyDirectoryUtils: LazyDirectoryUtils = {
  cast: lazyUtils.cast as LazyDirectoryUtils["cast"],
  get(this: Lazy<Directory>, path: string): Lazy<Value> {
    return createLazy(["file", "directory", "symlink"], {
      sourceDepth: 1,
      briocheSerialize: async (meta) => {
        const directory = await this.briocheSerialize();
        return {
          type: "get",
          directory,
          path: runtime.bstring(path),
          meta,
        }
      },
    });
  },
  insert(this: Lazy<Directory>, path: string, value: AsyncLazy<Value>): Lazy<Directory> {
    return createLazy(["directory"], {
      sourceDepth: 1,
      briocheSerialize: async (meta) => {
        const directory = await this.briocheSerialize();
        const newValue = await (await value).briocheSerialize();

        return {
          type: "merge",
          directories: [
            {
              type: "remove",
              directory,
              paths: [runtime.bstring(path)],
            },
            directoryStructure(path.split("/"), newValue),
          ],
          meta,
        }
      },
    });
  },
  remove(this: Lazy<Directory>, ...paths: string[]): Lazy<Directory> {
    return createLazy(["directory"], {
      sourceDepth: 1,
      briocheSerialize: async (meta) => {
        const directory = await this.briocheSerialize();
        return {
          type: "remove",
          directory,
          paths: paths.map(runtime.bstring),
          meta,
        }
      },
    });
  },
  peel(this: Lazy<Directory>, depth: number = 1): Lazy {
    return createLazy(["file", "directory", "symlink"], {
      sourceDepth: 1,
      briocheSerialize: async (meta) => {
        return {
          type: "peel",
          directory: await this.briocheSerialize(),
          depth,
          meta,
        };
      },
    });
  }
};

export const lazySymlinkUtils: LazySymlinkUtils = {
  cast: lazyUtils.cast as LazySymlinkUtils["cast"],
};
