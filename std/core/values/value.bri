import * as runtime from "../runtime.bri";
import { source as briocheSource } from "../source.bri";
import { type Awaitable, unreachable } from "../utils.bri";
import { File } from "./file.bri";
import { Directory } from "./directory.bri";
import { Symlink } from "./symlink.bri";
import { Download } from "./download.bri";
import { Unpack } from "./unpack.bri";
import { Process } from "./process.bri";

export type Value = File | Directory | Symlink;

export type LazyValueSerialization<T extends Value> = runtime.WithMeta & (
  T extends File ? (
    | runtime.CompleteFile
    | runtime.LazyDownload
    | runtime.LazyProcess
    | runtime.LazyCast
    | runtime.LazyPeel
    | runtime.LazyGet
    | runtime.LazySetPermissions
    | runtime.LazyProxy) :
  T extends Directory ? (
    | runtime.LazyDirectory
    | runtime.LazyUnpack
    | runtime.LazyProcess
    | runtime.LazyCast
    | runtime.LazyMerge
    | runtime.LazyPeel
    | runtime.LazyGet
    | runtime.LazyRemove
    | runtime.LazyProxy) :
  T extends Symlink ? (
    | runtime.CompleteSymlink
    | runtime.LazyProcess
    | runtime.LazyCast
    | runtime.LazyPeel
    | runtime.LazyGet
    | runtime.LazyProxy) :
  never
);

export interface Resolve<T extends Value = Value> {
  resolve(): Awaitable<T>;
}

export interface Lazy<T extends Value = Value> extends Resolve<T> {
  briocheSerialize(): Awaitable<LazyValueSerialization<T>>;
}

export type AsyncResolve<T extends Value = Value> = Awaitable<Resolve<T>>;

export type AsyncLazy<T extends Value = Value> = Awaitable<Lazy<T>>;

export async function asyncResolve<T extends Value>(value: AsyncResolve<T>): Promise<T> {
  return (await value).resolve();
}

export async function asyncBriocheSerialize<T extends Value>(value: AsyncLazy<T>): Promise<LazyValueSerialization<T>> {
  return (await value).briocheSerialize();
}

export function briocheDeserializeAny(value: runtime.CompleteValue, source: runtime.Source | undefined): Value {
  switch (value.type) {
    case "file":
      return File.briocheDeserialize(value, source);
    case "directory":
      return Directory.briocheDeserialize(value, source);
    case "symlink":
      return Symlink.briocheDeserialize(value, source);
    default:
      return unreachable(value);
  }
}

export type LazyOptions<T extends Value> = {
  sourceDepth?: number;
} & (
  | {
    briocheSerialize?(meta: runtime.Meta): Awaitable<LazyValueSerialization<T>>;
    resolve(meta: runtime.Meta): Awaitable<T>;
  }
  | {
    briocheSerialize(meta: runtime.Meta): Awaitable<LazyValueSerialization<T>>;
    resolve?(meta: runtime.Meta): Awaitable<T>;
  }
);

export type ValueType<T extends Value> = T extends File ? "file" : T extends Directory ? "directory" : T extends Symlink ? "symlink" : never;

export function createLazy<T extends Value>(types: ValueType<T>[], opts: LazyOptions<T>): Lazy<T> {
  const source = briocheSource({ depth: (opts.sourceDepth ?? 0) + 1 });
  const meta = { source };

  const isFile = types.some(type => type === "file");
  const isDirectory = types.some(type => type === "directory");
  const isSymlink = types.some(type => type === "symlink");

  return {
    briocheSerialize: async () => {
      if (opts.briocheSerialize) {
        return opts.briocheSerialize(meta);
      } else if (opts.resolve) {
        return (await opts.resolve(meta)).briocheSerialize();
      } else {
        throw new Error("resolve or briocheSerialize is required");
      }
    },
    resolve: async () => {
      if (opts.resolve) {
        return opts.resolve(meta);
      } else if (opts.briocheSerialize) {
        const result = await runtime.resolve(await opts.briocheSerialize(meta));
        return briocheDeserializeAny(result, source);
      } else {
        throw new Error("resolve or briocheSerialize is required");
      }
    },
  } as Lazy<T>;
}
