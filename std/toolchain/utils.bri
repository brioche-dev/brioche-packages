import * as std from "/core";

interface UseBriocheLdOptions {
  ldPaths: string[];
  interpreterPaths: Record<string, string>;
}

export function useBriocheLd(dir: std.Lazy<std.Directory>, options: UseBriocheLdOptions): std.Lazy<std.Directory> {
  const briocheLd = std.download({
    url: "https://development-content.brioche.dev/github.com/brioche-dev/brioche-pack/004166700c378bbcd77fb7fefcd05a0c14fc3cef/x86_64-unknown-linux-musl/brioche-ld",
    hash: std.sha256Hash("c504b122afac50bacf479217d9d2ad6363a3ec4f41861db028ff4899034b75c4"),
  });
  const briochePacked = std.download({
    url: "https://development-content.brioche.dev/github.com/brioche-dev/brioche-pack/004166700c378bbcd77fb7fefcd05a0c14fc3cef/x86_64-unknown-linux-musl/brioche-packed-userland-exec",
    hash: std.sha256Hash("4749179afacb19f611360e63b95e74c183c3e01e8104c0275d912d0e1725b154"),
  });

  for (const ldPath of options.ldPaths) {
    const systemLd = dir.get(ldPath);

    const ldDir = ldPath.split("/").slice(0, -1).join("/");
    const ldParentDirComponents = ldDir.split("/").slice(0, -1);
    const ldName = ldPath.split("/").at(-1);
    const ldParentName = ldDir.split("/").at(-1);
    std.assert(ldName != null && ldParentName != null);

    const briocheLdPath = [...ldParentDirComponents, "libexec", "brioche-ld"].join("/");
    let briocheLdDir: std.Lazy<std.Directory> = std.directory({
      "ld": std.symlink({ target: `../../${ldParentName}/${ldName}-orig` }),
      "brioche-packed": briochePacked.withPermissions({ executable: true }),
    });

    for (const [interpreterPath, interpreterTargetPath] of Object.entries(options.interpreterPaths)) {
      const interpreterDir = interpreterPath.split("/").slice(0, -1).join("/");
      const pathToBriocheLd = interpreterDir.split("/").map(() => "..").join("/");
      const pathToRoot = briocheLdPath.split("/").map(() => "..").join("/");
      const interpreterTarget = `${pathToBriocheLd}/${pathToRoot}/${interpreterTargetPath}`;
      briocheLdDir = briocheLdDir.insert(interpreterPath, std.symlink({ target: interpreterTarget }));
    };

    dir = dir.insert(`${ldDir}/${ldName}-orig`, systemLd);
    dir = dir.insert(ldPath, briocheLd.withPermissions({ executable: true }));
    dir = dir.insert(briocheLdPath, briocheLdDir);
  }

  return dir;
}

interface WrapWithScriptOptions {
  paths: string[];
  renameSuffix: string;
  script: std.AsyncLazy<std.File>;
}

export function wrapWithScript(dir: std.Lazy<std.Directory>, options: WrapWithScriptOptions): std.Lazy<std.Directory> {
  for (const path of options.paths) {
    const program = dir.get(path);

    dir = dir.insert(path, options.script);
    dir = dir.insert(`${path}${options.renameSuffix}`, program);
  }

  return dir;
}

export function makeFile(data: string, executable: boolean): std.Lazy<std.File> {
  const file = std.process({
    command: "/usr/bin/env",
    args: [
      "sh",
      "-c",
      'echo "$DATA" > "$BRIOCHE_OUTPUT"',
    ],
    env: {
      DATA: data,
      BRIOCHE_OUTPUT: std.outputPath,
    },
  }).cast("file");
  return file.withPermissions({ executable });
}
