import * as std from "std";
import * as typer from "typer";

export const project = {
  name: "go",
  version: "1.25.6",
  repository: "https://github.com/golang/go",
  extra: {
    otherVersions: {
      "1.25": "1.25.6",
      "1.24": "1.24.12",
    },
  },
};

std.assert(
  Object.keys(project.extra.otherVersions).some((minorVersion) =>
    project.version.startsWith(`${minorVersion}.`),
  ),
  "Go package version not found in extra.otherVersions",
);

/**
 * The Go version.
 */
export type GoVersion = keyof typeof project.extra.otherVersions;

function getLatestVersion(): GoVersion {
  const versions = Object.keys(project.extra.otherVersions);
  versions.sort((a, b) => parseInt(b) - parseInt(a));

  return versions[0] as GoVersion;
}

const prebuiltBinaries: Record<
  string,
  Record<string, std.Recipe<std.Directory>>
> = {
  "1.25": {
    "x86_64-linux": Brioche.download(
      `https://go.dev/dl/go${project.extra.otherVersions["1.25"]}.linux-amd64.tar.gz`,
    )
      .unarchive("tar", "gzip")
      .peel(),
    "aarch64-linux": Brioche.download(
      `https://go.dev/dl/go${project.extra.otherVersions["1.25"]}.linux-arm64.tar.gz`,
    )
      .unarchive("tar", "gzip")
      .peel(),
  },
  "1.24": {
    "x86_64-linux": Brioche.download(
      `https://go.dev/dl/go${project.extra.otherVersions["1.24"]}.linux-amd64.tar.gz`,
    )
      .unarchive("tar", "gzip")
      .peel(),
    "aarch64-linux": Brioche.download(
      `https://go.dev/dl/go${project.extra.otherVersions["1.24"]}.linux-arm64.tar.gz`,
    )
      .unarchive("tar", "gzip")
      .peel(),
  },
} satisfies Record<GoVersion, Record<std.Platform, std.Recipe<std.Directory>>>;

function prebuiltBinary(
  version: GoVersion,
  platform: std.Platform,
): std.Recipe<std.Directory> {
  const prebuiltBinariesForVersion = prebuiltBinaries[version];
  std.assert(
    prebuiltBinariesForVersion != null,
    `Go version '${version}' is not supported, expected one of ${JSON.stringify(
      Object.keys(prebuiltBinaries),
    )}`,
  );

  const prebuilt = prebuiltBinariesForVersion[platform];
  std.assert(
    prebuilt != null,
    `Go ${version} is not supported for ${platform}, expected one of ${JSON.stringify(
      Object.keys(prebuiltBinariesForVersion),
    )}`,
  );

  return prebuilt;
}

/**
 * Extra options for Go.
 *
 * @param version - The major version of Go to use. Defaults to the
 *   current stable release (at the time the `go` Brioche package was
 *   last updated).
 */
interface GoOptions {
  version?: GoVersion;
}

/**
 * The Go programming language.
 *
 * @param options - The options for installing the go package.
 *
 * @returns a recipe containing the standard Go tools, including:
 *
 * - `go/bin/go`
 * - `go/bin/gofmt`
 * - `bin/go` (symlink to `go/bin/go`)
 * - `bin/gofmt` (symlink to `go/bin/gofmt`)
 *
 * The directory `go` is intended to be used as the `$GOROOT` env var.
 */
export default function go(options: GoOptions = {}): std.Recipe<std.Directory> {
  const { version = getLatestVersion() } = options;

  return std
    .directory({
      go: prebuiltBinary(version, std.CURRENT_PLATFORM),
      bin: std.directory({
        go: std.symlink({ target: "../go/bin/go" }),
        gofmt: std.symlink({ target: "../go/bin/gofmt" }),
      }),
    })
    .pipe((recipe) =>
      std.setEnv(recipe, {
        GOROOT: { fallback: { path: "go" } },
      }),
    )
    .pipe((recipe) => std.withRunnableLink(recipe, "go/bin/go"));
}

export function test(): std.Recipe<std.Directory> {
  const goVersions = Object.keys(project.extra.otherVersions) as GoVersion[];

  const tests = goVersions.map(async (version) => {
    const script = std.runBash`
      go version | tee "$BRIOCHE_OUTPUT"
    `
      .dependencies(go({ version }))
      .toFile();

    const result = (await script.read()).trim();

    // Check that the result contains the expected version
    const expected = `go version go${project.extra.otherVersions[version]}`;
    std.assert(
      result.startsWith(expected),
      `expected '${expected}', got '${result}'`,
    );

    return std.directory().insert(version, script);
  });

  return std.merge(...tests);
}

export function liveUpdate(): std.Recipe<std.Directory> {
  return std.liveUpdateFromGithubTags({
    project,
    matchTag: /^go(?<version>\d+\.\d+\.\d+)$/,
  });
}

type ModOptions = "readonly" | "vendor" | "mod";

/**
 * Build options when building and installing a Go module.
 *
 * @param generate - Run `go generate` before building.
 * @param ldflags - An array of ldflags to pass to the `go install` command.
 * @param trimpath - Set the `-trimpath` flag.
 * @param mod - Set the `-mod` flag to one of `"readonly"`, `"vendor"`, or `"mod"`.
 */
interface GoBuildParameters {
  generate?: boolean;
  ldflags?: string[];
  trimpath?: boolean;
  mod?: ModOptions;
}

/**
 * Options for building and installing a Go module.
 *
 * @param source - The Go module to build. Should include `go.mod`, as well as
 *   `go.sum` if external dependencies are needed.
 * @param dependencies - Optionally add additional dependencies to the build.
 * @param env - Optionally set environment variables for the build.
 * @param currentDir - Optionally set the current working directory for the build.
 * @param buildParams - Optional build parameters.
 * @param path - Optionally set the package path to build (e.g. `./cmd/foo`).
 * @param runnable - Optionally set a path to the binary to run
 *   by default (e.g. `bin/foo`).
 */
interface GoBuildOptions {
  source: std.RecipeLike<std.Directory>;
  dependencies?: std.RecipeLike<std.Directory>[];
  env?: Record<string, std.ProcessTemplateLike>;
  currentDir?: string;
  buildParams?: GoBuildParameters;
  path?: string;
  runnable?: string;
}

/**
 * Build a Go module. Calls `go install` in the module directory, and
 * returns a recipe with the results stored in the `bin/` directory.
 *
 * @param options - Options for building the Go module.
 *
 * @returns A recipe with the built Go binaries stored in the `bin/` directory
 *
 * @example
 * ```typescript
 * import { goBuild } from "go";
 * import openssl from "openssl";
 *
 * export default function (): std.Recipe<std.Directory> {
 *   return goBuild({
 *     source: Brioche.glob("**\/*.go", "go.mod", "go.sum"),
 *     dependencies: [openssl],
 *     env: {
 *       CGO_ENABLED: "0",
 *     },
 *     buildParams: {
 *       generate: true,
 *       trimpath: true,
 *       mod: "readonly",
 *       ldflags: [
 *         "-s",
 *         "-w"
 *       ],
 *     },
 *     path: "./cmd/hello",
 *     runnable: "bin/hello",
 *   });
 * };
 * ```
 */
export function goBuild(options: GoBuildOptions): std.Recipe<std.Directory> {
  const modules = goModDownload(options.source, options.currentDir);

  return std.runBash`
    # Run generate if requested
    if [ "$go_generate" = "true" ]; then
      go generate ./...
    fi

    goargs=()

    if [ -n "$ldflags" ]; then
      goargs+=("-ldflags=$ldflags")
    fi

    if [ "$trimpath" = "true" ]; then
      goargs+=("-trimpath")
    fi

    if [ -n "$mod" ]; then
      goargs+=("-mod=$mod")
    fi

    go install "\${goargs[@]}" "$package_path"
  `
    .workDir(options.source)
    .currentDir(std.tpl`${std.workDir}/${options.currentDir}`)
    .dependencies(go, ...(options.dependencies ?? []))
    .env({
      GOMODCACHE: modules,
      GOBIN: std.tpl`${std.outputPath}/bin`,
      go_generate: options.buildParams?.generate ?? false ? "true" : "false",
      ldflags: ldflagsWrapper(options.buildParams?.ldflags ?? []),
      trimpath: options.buildParams?.trimpath ?? false ? "true" : "false",
      mod: options.buildParams?.mod ?? "",
      package_path: options.path ?? ".",
      ...options.env,
    })
    .toDirectory()
    .pipe((recipe) => std.withRunnableLink(recipe, options.runnable));
}

function goModDownload(
  goModule: std.RecipeLike<std.Directory>,
  currentDir: string | undefined,
): std.Recipe<std.Directory> {
  // Includes all the modules in the specified directory and its subdirectories
  // If a workspace file exists also include it
  return std
    .process({
      command: std.tpl`${go}/bin/go`,
      args: ["mod", "download", "all"],
      workDir: std.glob(goModule, [
        "**/go.mod",
        "**/go.sum",
        "**/go.work",
        "**/go.work.sum",
      ]),
      currentDir: std.tpl`${std.workDir}/${currentDir}`,
      env: {
        GOMODCACHE: std.outputPath,
      },
      // Ensure the output directory exists even when there are no dependencies,
      // as `go mod download` would not create it
      outputScaffold: std.directory(),
      unsafe: { networking: true },
    })
    .toDirectory();
}

/**
 * Wrapper function to escape ldflags for use in a shell command.
 * Escapes single quotes and double quotes.
 *
 * @param ldflags - An array of ldflags to escape.
 * @returns A string of escaped ldflags.
 */
function ldflagsWrapper(ldflags: string[]): string {
  return ldflags.map((ldflag) => ldflag.replace(/['"]/g, "\\$&")).join(" ");
}

/**
 * Type definition for module information (for private usage).
 *
 * @remarks The information of the module is obtained from the Go proxy registry.
 */
const ModuleInfo = typer.object({
  Version: typer.string(),
  Time: typer.string(),
  Origin: typer.object({
    VCS: typer.string(),
    URL: typer.string(),
    Hash: typer.string(),
    Ref: typer.string(),
  }),
});

/**
 * Type definition for module origin information (for public usage).
 *
 * @remarks The information of the module's origin is obtained from the Go proxy registry.
 *
 * @param vcs - The version control system of the module.
 * @param url - The URL of the module.
 * @param hash - The hash of the module.
 * @param ref - The reference of the module's version.
 */
interface GoModuleOriginInfo {
  vcs: string;
  url: string;
  hash: string;
  ref: string;
}

/**
 * Type definition for module information (for public usage).
 *
 * @remarks The information of the module is obtained from the Go proxy registry.
 *
 * @param version - The version of the module.
 * @param time - The time when the module was created.
 * @param origin - The origin information of the module.
 */
interface GoModuleInfo {
  version: string;
  time: string;
  origin: GoModuleOriginInfo;
}

export async function goModuleManifest(
  manifestUrl: std.Recipe<std.File>,
): Promise<GoModuleInfo> {
  const rawManifest = typer.parseJson(ModuleInfo, await manifestUrl.read());

  const moduleOrigin = {
    vcs: rawManifest.Origin.VCS,
    url: rawManifest.Origin.URL,
    hash: rawManifest.Origin.Hash,
    ref: rawManifest.Origin.Ref,
  };

  const manifest = {
    // Remove the leading 'v' from the version string
    version: rawManifest.Version.startsWith("v")
      ? rawManifest.Version.slice(1)
      : rawManifest.Version,
    time: rawManifest.Time,
    origin: moduleOrigin,
  };

  return manifest;
}
