import * as std from "std";
import caCertificates from "ca_certificates";

export const project = {
  name: "go",
  version: "1.22.5",
};

/**
 * The Go programming language.
 *
 * Returns a recipe containing the standard Go tools, including:
 *
 * - `go/bin/go`
 * - `go/bin/gofmt`
 * - `bin/go` (symlink to `go/bin/go`)
 * - `bin/gofmt` (symlink to `go/bin/gofmt`)
 *
 * The directory `go` is intended to be used as the `$GOROOT` env var.
 */
export function go(): std.Recipe<std.Directory> {
  const goRoot = std
    .download({
      url: `https://go.dev/dl/go${project.version}.linux-amd64.tar.gz`,
      hash: std.sha256Hash(
        "904b924d435eaea086515bc63235b192ea441bd8c9b198c507e85009e6e4c7f0",
      ),
    })
    .unarchive("tar", "gzip")
    .peel();

  let go = std.directory({
    go: goRoot,
    bin: std.directory({
      go: std.symlink({ target: "../go/bin/go" }),
      gofmt: std.symlink({ target: "../go/bin/gofmt" }),
    }),
  });
  go = std.setEnv(go, {
    GOROOT: { path: "go" },
  });
  go = std.withRunnableLink(go, "go/bin/go");

  return go;
}
export default go;

type ModOptions = "readonly" | "vendor" | "mod";

interface GoBuildParameters {
  generate?: boolean;
  ldflags?: string[];
  trimpath?: boolean;
  mod?: ModOptions;
}

interface GoBuildOptions {
  goModule: std.AsyncRecipe<std.Directory>;
  env?: Record<string, std.ProcessTemplateLike>;
  buildParams?: GoBuildParameters;
  packagePath?: string;
  runnable?: string;
}

/**
 * Build a Go module. Calls `go install` in the module directory, and
 * returns a recipe with the results stored in the `bin/` directory.
 *
 * ## Options
 *
 * - `goModule`: The Go module to build. Should include `go.mod`, as well as
 *   `go.sum` if external dependencies are needed.
 * - `buildParams`: Optional build parameters:
 *   - `generate`: Run `go generate` before building.
 *   - `ldflags`: An array of ldflags to pass to the `go install` command.
 *   - `trimpath`: Set the `-trimpath` flag.
 *   - `mod`: Set the `-mod` flag to one of `"readonly"`, `"vendor"`, or `"mod"`.
 * - `env`: Optionally set environment variables for the build.
 * - `packagePath`: Optionally set the package path to build (e.g. `./cmd/foo`).
 * - `runnable`: Optionally set a path to the binary to run
 *   by default (e.g. `bin/foo`).
 *
 * ## Example
 *
 * ```typescript
 * import { goInstall } from "go";
 *
 * export default function {
 *   return goInstall({
 *     goModule: Brioche.glob("**\/*.go", "go.mod", "go.sum"),
 *     env: {
 *       CGO_ENABLED: "0",
 *     },
 *     buildParams: {
 *       generate: true,
 *       trimpath: true,
 *       mod: "readonly",
 *       ldflags: [
 *         "-s",
 *         "-w"
 *       ],
 *     },
 *     packagePath: "./cmd/hello",
 *     runnable: "bin/hello",
 *   });
 * };
 * ```
 */
export async function goInstall(
  options: GoBuildOptions,
): Promise<std.Recipe<std.Directory>> {
  const modules = goModDownload(options.goModule);

  let buildResult = std.runBash`
    # Run generate if requested
    if [ "$go_generate" = "true" ]; then
      go generate ./...
    fi

    goargs=()

    if [ -n "$ldflags" ]; then
      goargs+=("-ldflags=$ldflags")
    fi

    if [ "$trimpath" = "true" ]; then
      goargs+=("-trimpath")
    fi

    if [ -n "$mod" ]; then
      goargs+=("-mod=$mod")
    fi

    go install "\${goargs[@]}" "$package_path"
  `
    .workDir(options.goModule)
    .dependencies(go(), std.toolchain())
    .env({
      GOMODCACHE: modules,
      GOBIN: std.tpl`${std.outputPath}/bin`,
      go_generate: options.buildParams?.generate ?? false ? "true" : "false",
      ldflags: ldflagsWrapper(options.buildParams?.ldflags ?? []),
      trimpath: options.buildParams?.trimpath ?? false ? "true" : "false",
      mod: options.buildParams?.mod ?? "",
      package_path: options.packagePath ?? ".",
      ...options.env,
    })
    .toDirectory();

  if (options.runnable != null) {
    buildResult = std.withRunnableLink(buildResult, options.runnable);
  }

  return buildResult;
}

async function goModDownload(
  goModule: std.AsyncRecipe<std.Directory>,
): Promise<std.Recipe<std.Directory>> {
  let goModuleDir = await goModule;

  // HACK: Used so we can optionally grab `go.sum` (and fallback to an empty
  // file if it isn't present). This should be replaced with a recipe to
  // slice the `goModule` recipe using paths or glob patterns.
  goModuleDir = std.merge(
    std.directory({
      "go.sum": std.file(""),
    }),
    goModuleDir,
  );

  return std.runBash`
    go mod download all
  `
    .workDir(
      std.directory({
        "go.mod": goModuleDir.get("go.mod"),
        "go.sum": goModuleDir.get("go.sum"),
      }),
    )
    .dependencies(go(), caCertificates())
    .env({ GOMODCACHE: std.outputPath })
    .unsafe({ networking: true })
    .toDirectory();
}

/**
 * Wrapper function to escape ldflags for use in a shell command.
 * Escapes single quotes and double quotes.
 *
 * @param ldflags An array of ldflags to escape.
 * @returns A string of escaped ldflags.
 */
function ldflagsWrapper(ldflags: string[]): string {
  return ldflags.map((ldflag) => ldflag.replace(/['"]/g, "\\$&")).join(" ");
}
