import * as std from "/core";
import { runBash } from "./run_bash.bri";

export const PKG_CONFIG_MAKE_PATHS_RELATIVE_SCRIPT = std.indoc`
  make_pkg_config_paths_relative () {
    local -r file="$1"

    # Update prefix, exec_prefix, libdir and includedir variables
    sed -i 's|^prefix[[:space:]]*=.*|prefix=\${pcfiledir}/../..|' "$file"
    sed -i 's|^exec_prefix[[:space:]]*=.*|exec_prefix=\${prefix}|' "$file"
    sed -i 's|^libdir[[:space:]]*=.*|libdir=\${prefix}/lib|' "$file"
    sed -i 's|^includedir[[:space:]]*=.*/include\\([^"]*\\)"\\?|includedir=\${prefix}/include\\1|' "$file"

    # Find and replace common patterns in Libs and Cflags variables
    sed -i -e "/^Libs:/ s|-L/[^[:space:]]*/lib|-L\\\${libdir}|g" "$file"
    sed -i -e "/^Libs:/ s|-Wl,-rpath,/[^[:space:]]*/lib|-Wl,-rpath,\\\${libdir}|g" "$file"
    sed -i -e "/^Cflags:/ s|-I/[^[:space:]]*/include|-I\\\${includedir}|g" "$file"
  }

  # Candidate pkg-config directories relative to $BRIOCHE_OUTPUT
  pkg_dirs=(lib/pkgconfig share/pkgconfig)

  # Collect only those that are present
  find_roots=()
  for rel in "\${pkg_dirs[@]}"; do
    dir="$BRIOCHE_OUTPUT/$rel"
    if [[ -d "$dir" ]]; then
      find_roots+=("$dir")
    fi
  done

  # No pkg-config dir found, exit
  if [[ \${#find_roots[@]} -eq 0 ]]; then
    exit 0
  fi

  find -L "\${find_roots[@]}" -name '*.pc' -type f -print0 \
    | while IFS= read -r -d $'\\0' file; do
      make_pkg_config_paths_relative "$file"
    done
`;

/**
 * Create a recipe that replaces absolute paths in pkg-config files with
 * relative paths using the `${pcfiledir}` variable.
 *
 * This is useful for ensuring that pkg-config files can be used in different
 * environments without needing to modify them manually.
 *
 * @param recipe - The recipe to apply the transformation to.
 *
 * @returns A new recipe with the transformed pkg-config files.
 *
 * @remarks This function looks for pkg-config files in the standard locations
 *   `lib/pkgconfig` and `share/pkgconfig` relative to the `$BRIOCHE_OUTPUT`
 *   output directory.
 */
export function pkgConfigMakePathsRelative(
  recipe: std.RecipeLike<std.Directory>,
): std.Recipe<std.Directory> {
  return runBash(PKG_CONFIG_MAKE_PATHS_RELATIVE_SCRIPT)
    .outputScaffold(recipe)
    .toDirectory();
}
