import * as std from "/core";
import { runBash } from "./run_bash.bri";

export const LIBTOOL_SANITIZE_DEPENDENCIES_SCRIPT = std.indoc`
  sanitize_libtool_dependencies () {
    local -r file="$1"

    sed -i -e "/^dependency_libs='/,/'/ s|//lib/lib\\([^[:space:]]*\\)\\.la|-l\\1|g" "$file"
  }

  # No lib dir found, exit
  if [[ ! -d "$BRIOCHE_OUTPUT/lib" ]]; then
    exit 0
  fi

  find -L "$BRIOCHE_OUTPUT/lib" -name '*.la' -type f -print0 \
    | while IFS= read -r -d $'\\0' file; do
      sanitize_libtool_dependencies "$file"
    done
`;

/**
 * Create a recipe that replaces dependencies absolute paths in libtool files
 * with the corresponding linker flag.
 *
 * This is useful for ensuring that libtool files can be used in different
 * environments without needing to modify them manually.
 *
 * @param recipe - The recipe to apply the transformation to.
 *
 * @returns A new recipe with the transformed libtool files.
 *
 * @remarks This function looks for libtool files in the standard locations
 *   `lib` relative to the `$BRIOCHE_OUTPUT` output directory, and updates
 *   the variable `dependency_libs`.
 */
export function libtoolSanitizeDependencies(
  recipe: std.RecipeLike<std.Directory>,
): std.Recipe<std.Directory> {
  return runBash(LIBTOOL_SANITIZE_DEPENDENCIES_SCRIPT)
    .outputScaffold(recipe)
    .toDirectory();
}
