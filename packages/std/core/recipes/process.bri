import { Awaitable, mixin } from "../utils.bri";
import * as runtime from "../runtime.bri";
import { type Directory, directory } from "./directory.bri";
import { type AsyncRecipe, type Recipe, createRecipe } from "./recipe.bri";

export type ProcessOptions = {
  command: ProcessTemplateLike;
  args?: ProcessTemplateLike[];
  env?: Record<string, ProcessTemplateLike>;
  dependencies?: AsyncRecipe<Directory>[];
  workDir?: AsyncRecipe<Directory>;
  outputScaffold?: AsyncRecipe | null;
} & ProcessUnsafeOptions;

export type ProcessUnsafeOptions =
  | { unsafe?: false }
  | ({ unsafe: true } & ProcessUnsafe);

export interface ProcessUnsafe {
  networking?: boolean;
}

export type Process = Recipe & ProcessUtils;

export interface ProcessUtils {
  /**
   * Returns a new process with more environment variables set.
   */
  env(values: Record<string, ProcessTemplateLike>): Process;

  /**
   * Returns a new process with more dependencies added. The new
   * dependencies take precedence over the old ones.
   */
  dependencies(...dependencies: AsyncRecipe<Directory>[]): Process;

  /**
   * Returns a new process with a different working directory.
   */
  workDir(workDir: AsyncRecipe<Directory>): Process;

  /**
   * Returns a new process with a different output scaffold.
   */
  outputScaffold(outputScaffold: AsyncRecipe): Process;

  /**
   * Returns a new process with unsafe options set.
   */
  unsafe(unsafeOptions: ProcessUnsafe): Process;
}

/**
 * Create a recipe that will run a process, returning the contents that
 * the process writes to the path `$BRIOCHE_OUTPUT`. The process can
 * write a file, directory, or symlink to this path.
 *
 * Most options can be passed as a string literal, or as a template using
 * the template function `std.tpl`. Recipes in the template will be
 * expanded to an absolute path when the process runs.
 *
 * ## Options
 *
 * These options can be passed when calling `std.process()`, or can be
 * set by calling methods on another process recipe (these methods are
 * **immutable**, so make sure to assign the result to a variable!)
 *
 * - `command`: The command to run. Should either be a template, or a
 *   string referencing a command from `dependencies`.
 * - `args`: An array of arguments to pass to the command.
 * - `env`: An object containing environment variables to set for the process.
 * - `dependencies`: An array of dependencies to call the process with.
 *   Dependencies will be merged into the process's environment.
 * - `workDir`: Set to a directory recipe that will be copied into the
 *   process's starting working directory.
 * - `outputScaffold`: Set to a recipe that will be be used to initialize
 *   `$BRIOCHE_OUTPUT`, which the process can then manipulate.
 * - `unsafe`: Set to `true` to use unsafe options. You must take extra
 *   care to ensure that running the process is hermetic when using these
 *   options! The following options are available:
 *   - `networking`: Set to `true` to allow the process to access the network.
 *
 * ## Example
 *
 * ```typescript
 * // Call Bash and write "Hello world!" to the output path
 * std.process({
 *   command: std.tpl`${std.tools()}/bin/bash`,
 *   args: ["-c", 'echo "Hello world!" > "$BRIOCHE_OUTPUT"'],
 * });
 */
export function process(options: ProcessOptions): Process {
  const env: Record<string, ProcessTemplateLike> = {
    BRIOCHE_OUTPUT: outputPath,
    BRIOCHE_RESOURCE_DIR: resourceDir,
    BRIOCHE_INPUT_RESOURCE_DIRS: inputResourceDirs,
    HOME: homeDir,
    TMPDIR: tempDir,
    ...options.env,
  };

  const bEnv: Record<runtime.BString, ProcessTemplate> = {};
  for (const [k, v] of Object.entries(env)) {
    bEnv[runtime.bstring(k)] = processTemplate(v);
  }

  const recipe = createRecipe(["file", "directory", "symlink"], {
    sourceDepth: 1,
    briocheSerialize: async (meta) => {
      return {
        type: "process",
        command: await processTemplate(options.command).briocheSerialize(),
        args: await Promise.all(
          (options.args ?? []).map(
            async (arg) => await processTemplate(arg).briocheSerialize(),
          ),
        ),
        env: Object.fromEntries(
          await Promise.all(
            Object.entries(env).map(async ([k, v]) => [
              k,
              await processTemplate(v).briocheSerialize(),
            ]),
          ),
        ),
        dependencies: await Promise.all(
          (options.dependencies ?? []).map(
            async (dep) => await (await dep).briocheSerialize(),
          ),
        ),
        platform: "x86_64-linux",
        workDir: await (
          await (options.workDir ?? directory())
        ).briocheSerialize(),
        outputScaffold:
          options.outputScaffold != null
            ? await (await options.outputScaffold).briocheSerialize()
            : null,
        unsafe: options.unsafe,
        networking: options.unsafe === true ? options.networking : undefined,
        meta,
      };
    },
  });

  return mixin(recipe, {
    env(this: Process, values: Record<string, ProcessTemplateLike>): Process {
      return process({
        ...options,
        env: {
          ...options.env,
          ...values,
        },
      });
    },
    dependencies(
      this: Process,
      ...dependencies: AsyncRecipe<Directory>[]
    ): Process {
      return process({
        ...options,
        dependencies: [...dependencies, ...(options.dependencies ?? [])],
      });
    },
    workDir(this: Process, workDir: AsyncRecipe<Directory>): Process {
      return process({
        ...options,
        workDir,
      });
    },
    outputScaffold(this: Process, outputScaffold: AsyncRecipe): Process {
      return process({
        ...options,
        outputScaffold,
      });
    },
    unsafe(this: Process, unsafeOptions: ProcessUnsafe): Process {
      return process({
        ...options,
        unsafe: true,
        ...unsafeOptions,
      });
    },
  } satisfies ProcessUtils);
}

export function processTemplate(
  ...components: ProcessTemplateLike[]
): ProcessTemplate {
  return new ProcessTemplate(...components);
}

/**
 * Create a process template, which can be used to include recipe paths
 * or other pre-defined values for the command, arguments, or environment
 * variables for a process.
 */
export function tpl(
  strings: TemplateStringsArray,
  ...items: ProcessTemplateLike[]
): ProcessTemplate {
  const components = strings.flatMap((str, i): ProcessTemplateLike[] => {
    const item = items[i];
    if (item != null) {
      return [str, item];
    } else {
      return [str];
    }
  });

  return new ProcessTemplate(...components);
}

/**
 * Expands to the path where the process should write its output. Equivalent
 * to the default environment variable `$BRIOCHE_OUTPUT`.
 */
export const outputPath: unique symbol = Symbol("outputPath");

/**
 * Expands to the directory where the process can write resources to that
 * can then be referenced by files in the process's output. Equivalent
 * to the default environment variable `$BRIOCHE_RESOURCE_DIR`.
 */
export const resourceDir: unique symbol = Symbol("resourceDir");

/**
 * Expands to a `:`-delimited list of directories where the process can find
 * resources from its inputs. These directories are normally read-only.
 * Equivalent to the default environment variable `$BRIOCHE_INPUT_RESOURCE_DIRS`.
 */
export const inputResourceDirs: unique symbol = Symbol("inputResourceDirs");

/**
 * Expands to the home directory when the process runs. Equivalent to the
 * default environment variable `$HOME`.
 */
export const homeDir: unique symbol = Symbol("homeDir");

/**
 * Expands to the the "work directory" of the process. This is the directory
 * a process starts in by default (which is usually `$HOME/work`).
 */
export const workDir: unique symbol = Symbol("workDir");

/**
 * Expands to the temporary directory where the process can write temporary
 * files. Equivalent to the default environment variable `$TMPDIR`.
 */
export const tempDir: unique symbol = Symbol("tempDir");

export type ProcessTemplateLike = Awaitable<ProcessTemplateComponent>;

export type ProcessTemplateComponent =
  | string
  | ProcessTemplate
  | Recipe
  | typeof outputPath
  | typeof resourceDir
  | typeof inputResourceDirs
  | typeof homeDir
  | typeof workDir
  | typeof tempDir
  | undefined;

export class ProcessTemplate {
  components: ProcessTemplateLike[];

  constructor(...components: ProcessTemplateLike[]) {
    /* eslint-disable-next-line */
    this.components = components;
  }

  async briocheSerialize(): Promise<runtime.ProcessTemplate> {
    const components = await Promise.all(this.components);
    const runtimeComponents = await Promise.all(
      components.map(
        async (component): Promise<runtime.ProcessTemplateComponent[]> => {
          if (component == null || component === "") {
            return [];
          } else if (typeof component === "string") {
            return [{ type: "literal", value: runtime.bstring(component) }];
          } else if (component === outputPath) {
            return [{ type: "output_path" }];
          } else if (component === resourceDir) {
            return [{ type: "resource_dir" }];
          } else if (component === inputResourceDirs) {
            return [{ type: "input_resource_dirs" }];
          } else if (component === homeDir) {
            return [{ type: "home_dir" }];
          } else if (component === workDir) {
            return [{ type: "work_dir" }];
          } else if (component === tempDir) {
            return [{ type: "temp_dir" }];
          } else if (component instanceof ProcessTemplate) {
            const serialized = await component.briocheSerialize();
            return serialized.components;
          } else {
            return [
              { type: "input", recipe: await component.briocheSerialize() },
            ];
          }
        },
      ),
    );

    return {
      components: runtimeComponents.flat(1),
    };
  }
}
