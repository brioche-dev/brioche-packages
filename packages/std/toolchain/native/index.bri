import * as std from "/core";
import { setEnv } from "/extra/set_env.bri";
import { buildAutopackConfig, AutopackOptions } from "/extra/autopack.bri";
import { runtimeUtils } from "/toolchain/utils.bri";
import linuxHeaders from "./linux_headers.bri";
import glibc from "./glibc.bri";
import zlib from "./zlib.bri";
import bzip2 from "./bzip2.bri";
import xz from "./xz.bri";
import zstd from "./zstd.bri";
import file from "./file.bri";
import readline from "./readline.bri";
import m4 from "./m4.bri";
import bc from "./bc.bri";
import flex from "./flex.bri";
import binutils from "./binutils.bri";
import gmp from "./gmp.bri";
import mpfr from "./mpfr.bri";
import mpc from "./mpc.bri";
import attr from "./attr.bri";
import acl from "./acl.bri";
import libxcrypt from "./libxcrypt.bri";
import gcc from "./gcc.bri";
import pkgconf from "./pkgconf.bri";
import ncurses from "./ncurses.bri";
import sed from "./sed.bri";
import psmisc from "./psmisc.bri";
import gettext from "./gettext.bri";
import bison from "./bison.bri";
import grep from "./grep.bri";
import bash from "./bash.bri";
import libtool from "./libtool.bri";
import gdbm from "./gdbm.bri";
import gperf from "./gperf.bri";
import expat from "./expat.bri";
import inetutils from "./inetutils.bri";
import less from "./less.bri";
import perl from "./perl.bri";
import perlXmlParser from "./perl_xml_parser.bri";
import intltool from "./intltool.bri";
import autoconf from "./autoconf.bri";
import automake from "./automake.bri";
import libelf from "./libelf.bri";
import coreutils from "./coreutils.bri";
import diffutils from "./diffutils.bri";
import gawk from "./gawk.bri";
import findutils from "./findutils.bri";
import groff from "./groff.bri";
import gzip from "./gzip.bri";
import libpipeline from "./libpipeline.bri";
import make from "./make.bri";
import patch from "./patch.bri";
import tar from "./tar.bri";
import texinfo from "./texinfo.bri";
import manDb from "./man_db.bri";
import procpsNg from "./procps_ng.bri";
import utilLinux from "./util_linux.bri";
import which from "./which.bri";
import patchelf from "./patchelf.bri";

export { bash };

const toolPackages = [
  zlib(),
  bzip2(),
  xz(),
  zstd(),
  file(),
  bc(),
  binutils(),
  sed(),
  grep(),
  bash(),
  coreutils(),
  diffutils(),
  gawk(),
  findutils(),
  gzip(),
  make(),
  patch(),
  tar(),
  which(),
];

const toolchainOnlyPackages = [
  linuxHeaders(),
  glibc(),
  readline(),
  m4(),
  flex(),
  gmp(),
  mpfr(),
  mpc(),
  attr(),
  acl(),
  libxcrypt(),
  gcc(),
  pkgconf(),
  ncurses(),
  psmisc(),
  gettext(),
  bison(),
  libtool(),
  gdbm(),
  gperf(),
  expat(),
  inetutils(),
  less(),
  perl(),
  perlXmlParser(),
  intltool(),
  autoconf(),
  automake(),
  libelf(),
  groff(),
  libpipeline(),
  texinfo(),
  manDb(),
  procpsNg(),
  utilLinux(),
  patchelf(),
];

/**
 * Returns a set of common Unix-style utilities
 */
export const tools = std.memo(async (): Promise<std.Recipe<std.Directory>> => {
  let tools = std.merge(...toolPackages);

  // Set env vars when used as a dependency. These are also used
  // when autopacking
  tools = setEnv(tools, {
    CPATH: { path: "include" },
    LIBRARY_PATH: { path: "lib" },
    PKG_CONFIG_PATH: { path: "lib/pkgconfig" },
    MAGIC: { path: "share/misc/magic.mgc" },
  });

  // Pack binaries and scripts
  tools = autopack(tools, {
    globs: ["bin/**"],
    selfDependency: true,
    linkDependencies: [toolchain()],
    dynamicBinaryConfig: {
      enabled: true,
    },
    sharedLibraryConfig: {
      enabled: false,
    },
    scriptConfig: {
      enabled: true,
    },
    repackConfig: {
      enabled: true,
    },
  });

  return std.sync(tools);
});

/**
 * Returns a complete toolchain, including a C compiler and common libraries.
 * Includes all tools from `tools`.
 */
export const toolchain = std.memo(
  async (): Promise<std.Recipe<std.Directory>> => {
    // Merge all the packages
    const unpackedToolchain = std.merge(
      ...toolchainOnlyPackages,
      ...toolPackages,
    );

    let toolchain = unpackedToolchain;

    // Add a symlink for the C compiler
    toolchain = toolchain.insert("bin/cc", std.symlink({ target: "gcc" }));

    // Set env vars when used as a dependency. These are also used
    // when autopacking
    toolchain = setEnv(toolchain, {
      CPATH: { path: "include" },
      LIBRARY_PATH: [
        { path: "lib" },
        { path: "lib/man-db" },
        { path: "lib/gconv" },
      ],
      PKG_CONFIG_PATH: { path: "lib/pkgconfig" },
      MAGIC: { path: "share/misc/magic.mgc" },
    });

    // Pack scripts from autoconf
    toolchain = autopack(toolchain, {
      paths: [
        "bin/autoconf",
        "bin/autoheader",
        "bin/autom4te",
        "bin/autom4te-orig",
        "bin/autoreconf",
        "bin/autoscan",
        "bin/autoupdate",
        "bin/autoupdate-orig",
        "bin/ifnames",
      ],
      selfDependency: true,
      scriptConfig: {
        env: {
          AUTOCONF: {
            type: "fallback",
            value: { relativePath: "bin/autoconf" },
          },
          AUTOHEADER: {
            type: "fallback",
            value: { relativePath: "bin/autoheader" },
          },
          AUTOM4TE: {
            type: "fallback",
            value: { relativePath: "bin/autom4te" },
          },
          M4: { type: "fallback", value: { relativePath: "bin/m4" } },
          autom4te_perllibdir: {
            type: "fallback",
            value: { relativePath: "share/autoconf" },
          },
          AC_MACRODIR: {
            type: "fallback",
            value: { relativePath: "share/autoconf" },
          },
        },
      },
    });

    // Pack scripts from automake
    toolchain = autopack(toolchain, {
      globs: ["bin/automake", "bin/automake-*", "bin/aclocal", "bin/aclocal-*"],
      selfDependency: true,
      scriptConfig: {
        env: {
          AUTOMAKE_UNINSTALLED: { type: "fallback", value: "1" },
          AUTOM4TE: {
            type: "fallback",
            value: { relativePath: "bin/autom4te" },
          },
          trailer_m4: {
            type: "set",
            value: { relativePath: "share/autoconf/autoconf/trailer.m4" },
          },
          ACLOCAL_PATH: {
            type: "append",
            value: { relativePath: "share/aclocal" },
            separator: ":",
          },
          ACLOCAL_AUTOMAKE_DIR: {
            type: "fallback",
            value: { relativePath: "share/aclocal-1.16" },
          },
        },
      },
    });

    // Pack all other scripts
    toolchain = autopack(toolchain, {
      globs: ["bin/**"],
      selfDependency: true,
      dynamicBinaryConfig: {
        enabled: false,
      },
      sharedLibraryConfig: {
        enabled: false,
      },
      scriptConfig: {
        enabled: true,
      },
    });

    // Re-pack all dynamic binaries. This is done so they reference libraries
    // from the toolchain itself. Note that libraries are not packed, mainly
    // since libc specifically should not be packed.
    toolchain = autopack(toolchain, {
      globs: ["bin/**"],
      selfDependency: true,
      dynamicBinaryConfig: {
        enabled: true,
      },
      sharedLibraryConfig: {
        enabled: false,
      },
      scriptConfig: {
        enabled: false,
      },
      repackConfig: {
        enabled: true,
      },
    });

    // Keep the unpacked version of several wrapper scripts
    const keepUnpackedPaths = [
      "bin/x86_64-pc-linux-gnu-c++",
      "bin/x86_64-pc-linux-gnu-g++",
      "bin/x86_64-pc-linux-gnu-gcc",
      "bin/x86_64-pc-linux-gnu-gcc-13.2.0",
      "bin/c++",
      "bin/g++",
      "bin/gcc",
    ];
    for (const path of keepUnpackedPaths) {
      toolchain = toolchain.insert(path, unpackedToolchain.get(path));
    }

    toolchain = std.sync(toolchain);

    return toolchain;
  },
);

function autopack(
  recipe: std.AsyncRecipe<std.Directory>,
  options: AutopackOptions,
): std.Recipe<std.Directory> {
  const { config, variables } = buildAutopackConfig({
    options,
    defaultLinkDependencies: [],
    runtimeUtils: runtimeUtils(),
  });

  const variableArgs: std.ProcessTemplateLike[] = Object.entries(
    variables,
  ).flatMap(([name, value]) => {
    switch (value.type) {
      case "path":
        return ["--var", std.tpl`${name}=path:${value.value}`];
    }
  });

  return std
    .process({
      command: std.tpl`${runtimeUtils()}/bin/brioche-packer`,
      args: [
        "autopack",
        std.outputPath,
        "--config",
        JSON.stringify(config),
        ...variableArgs,
      ],
      outputScaffold: recipe,
    })
    .toDirectory();
}
