import * as std from "/core";
import { setEnv } from "/extra/set_env.bri";
import { buildAutopackConfig, AutopackOptions } from "/extra/autopack.bri";
import {
  buildPackRunnableConfig,
  EnvValueConfig,
} from "/extra/pack_runnable.bri";
import { runtimeUtils } from "/toolchain/utils.bri";
import linuxHeaders from "./linux_headers.bri";
import glibc from "./glibc.bri";
import zlib from "./zlib.bri";
import bzip2 from "./bzip2.bri";
import xz from "./xz.bri";
import zstd from "./zstd.bri";
import file from "./file.bri";
import readline from "./readline.bri";
import m4 from "./m4.bri";
import bc from "./bc.bri";
import flex from "./flex.bri";
import binutils from "./binutils.bri";
import gmp from "./gmp.bri";
import mpfr from "./mpfr.bri";
import mpc from "./mpc.bri";
import attr from "./attr.bri";
import acl from "./acl.bri";
import libxcrypt from "./libxcrypt.bri";
import gcc from "./gcc.bri";
import pkgconf from "./pkgconf.bri";
import ncurses from "./ncurses.bri";
import sed from "./sed.bri";
import psmisc from "./psmisc.bri";
import gettext from "./gettext.bri";
import bison from "./bison.bri";
import grep from "./grep.bri";
import bash from "./bash.bri";
import libtool from "./libtool.bri";
import gdbm from "./gdbm.bri";
import gperf from "./gperf.bri";
import expat from "./expat.bri";
import inetutils from "./inetutils.bri";
import less from "./less.bri";
import perl from "./perl.bri";
import perlXmlParser from "./perl_xml_parser.bri";
import intltool from "./intltool.bri";
import autoconf from "./autoconf.bri";
import automake from "./automake.bri";
import libelf from "./libelf.bri";
import coreutils from "./coreutils.bri";
import diffutils from "./diffutils.bri";
import gawk from "./gawk.bri";
import findutils from "./findutils.bri";
import groff from "./groff.bri";
import gzip from "./gzip.bri";
import libpipeline from "./libpipeline.bri";
import make from "./make.bri";
import patch from "./patch.bri";
import tar from "./tar.bri";
import texinfo from "./texinfo.bri";
import manDb from "./man_db.bri";
import procpsNg from "./procps_ng.bri";
import utilLinux from "./util_linux.bri";
import which from "./which.bri";
import patchelf from "./patchelf.bri";

export { bash };

const toolPackages = [
  zlib(),
  bzip2(),
  xz(),
  zstd(),
  file(),
  bc(),
  sed(),
  grep(),
  bash(),
  coreutils(),
  diffutils(),
  gawk(),
  findutils(),
  gzip(),
  make(),
  patch(),
  tar(),
  which(),
];

const toolchainOnlyPackages = [
  linuxHeaders(),
  glibc(),
  readline(),
  m4(),
  flex(),
  binutils(),
  gmp(),
  mpfr(),
  mpc(),
  attr(),
  acl(),
  libxcrypt(),
  gcc(),
  pkgconf(),
  ncurses(),
  psmisc(),
  gettext(),
  bison(),
  libtool(),
  gdbm(),
  gperf(),
  expat(),
  inetutils(),
  less(),
  perl(),
  perlXmlParser(),
  intltool(),
  autoconf(),
  automake(),
  libelf(),
  groff(),
  libpipeline(),
  texinfo(),
  manDb(),
  procpsNg(),
  utilLinux(),
  patchelf(),
];

/**
 * Returns a set of common Unix-style utilities
 */
export const tools = std.memo(async (): Promise<std.Recipe<std.Directory>> => {
  let tools = std.merge(...toolPackages);

  // Pack binaries and scripts
  tools = autopack(tools, {
    globs: ["bin/**"],
    linkDependencies: [toolchain()],
    dynamicBinaryConfig: {
      enabled: true,
    },
    sharedLibraryConfig: {
      enabled: false,
    },
    scriptConfig: {
      enabled: true,
    },
    repackConfig: {
      enabled: true,
    },
  });

  // Only take the binaries (plus the magic file)
  tools = std.directory({
    bin: tools.get("bin"),
    share: std.directory({
      misc: std.directory({
        "magic.mgc": tools.get("share/misc/magic.mgc"),
      }),
    }),
  });

  // Set `$MAGIC` env var for `file` when used as a dependency
  tools = setEnv(tools, {
    MAGIC: { path: "share/misc/magic.mgc" },
  });

  return std.sync(tools);
});

/**
 * Returns a complete toolchain, including a C compiler and common libraries.
 * Includes all tools from `tools`.
 */
export const toolchain = std.memo(
  async (): Promise<std.Recipe<std.Directory>> => {
    // Merge all the packages
    const unpackedToolchain = std.merge(
      ...toolchainOnlyPackages,
      ...toolPackages,
    );

    let toolchain = unpackedToolchain;

    // Add a symlink for the C compiler
    toolchain = toolchain.insert("bin/cc", std.symlink({ target: "gcc" }));

    // Set env vars when used as a dependency. These are also used
    // when autopacking
    toolchain = setEnv(toolchain, {
      CPATH: { path: "include" },
      LIBRARY_PATH: [
        { path: "lib" },
        { path: "lib/man-db" },
        { path: "lib/gconv" },
      ],
      PKG_CONFIG_PATH: { path: "lib/pkgconfig" },
      MAGIC: { path: "share/misc/magic.mgc" },
    });

    // Pack scripts from autoconf
    toolchain = withPackedRunnableScripts(toolchain, {
      paths: [
        "bin/autoconf",
        "bin/autoheader",
        "bin/autom4te",
        "bin/autom4te-orig",
        "bin/autoreconf",
        "bin/autoscan",
        "bin/autoupdate",
        "bin/autoupdate-orig",
        "bin/ifnames",
      ],
      command: std.tpl`${perl()}/bin/perl`,
      args: ["--"],
      env: {
        PERL5LIB: {
          type: "append",
          value: {
            relativePaths: ["../share/autoconf"],
            separator: ":",
          },
          separator: ":",
        },
        AUTOCONF: {
          type: "fallback",
          value: { relativePath: "../bin/autoconf" },
        },
        AUTOHEADER: {
          type: "fallback",
          value: { relativePath: "../bin/autoheader" },
        },
        AUTOM4TE: {
          type: "fallback",
          value: { relativePath: "../bin/autom4te" },
        },
        M4: { type: "fallback", value: { relativePath: "../bin/m4" } },
        autom4te_perllibdir: {
          type: "fallback",
          value: { relativePath: "../share/autoconf" },
        },
        AC_MACRODIR: {
          type: "fallback",
          value: { relativePath: "../share/autoconf" },
        },
      },
    });
    // toolchain = autopack(toolchain, {
    //   paths: [
    //     "bin/autoconf",
    //     "bin/autoheader",
    //     "bin/autom4te",
    //     "bin/autom4te-orig",
    //     "bin/autoreconf",
    //     "bin/autoscan",
    //     "bin/autoupdate",
    //     "bin/autoupdate-orig",
    //     "bin/ifnames",
    //   ],
    //   selfDependency: true,
    //   scriptConfig: {
    //     env: {
    //       PERL5LIB: {
    //         type: "append",
    //         value: {
    //           relativePaths: [
    //             "lib/perl5/site_perl/5.38.0/x86_64-linux-thread-multi",
    //             "lib/perl5/site_perl/5.38.0",
    //             "lib/perl5/5.38.0/x86_64-linux-thread-multi",
    //             "lib/perl5/5.38.0",
    //             "share/autoconf",
    //           ],
    //           separator: ":",
    //         },
    //         separator: ":",
    //       },
    //       AUTOCONF: {
    //         type: "fallback",
    //         value: { relativePath: "bin/autoconf" },
    //       },
    //       AUTOHEADER: {
    //         type: "fallback",
    //         value: { relativePath: "bin/autoheader" },
    //       },
    //       AUTOM4TE: {
    //         type: "fallback",
    //         value: { relativePath: "bin/autom4te" },
    //       },
    //       M4: { type: "fallback", value: { relativePath: "bin/m4" } },
    //       autom4te_perllibdir: {
    //         type: "fallback",
    //         value: { relativePath: "share/autoconf" },
    //       },
    //       AC_MACRODIR: {
    //         type: "fallback",
    //         value: { relativePath: "share/autoconf" },
    //       },
    //     },
    //   },
    // });

    // Pack scripts from automake
    toolchain = withPackedRunnableScripts(toolchain, {
      paths: [
        "bin/automake",
        "bin/automake-1.16",
        "bin/aclocal",
        "bin/aclocal-1.16",
      ],
      command: std.tpl`${perl()}/bin/perl`,
      args: ["--"],
      env: {
        PERL5LIB: {
          type: "append",
          value: {
            relativePaths: ["../share/automake-1.16"],
            separator: ":",
          },
          separator: ":",
        },
        AUTOMAKE_UNINSTALLED: { type: "fallback", value: "1" },
        AUTOM4TE: {
          type: "fallback",
          value: { relativePath: "../bin/autom4te" },
        },
        trailer_m4: {
          type: "set",
          value: { relativePath: "../share/autoconf/autoconf/trailer.m4" },
        },
        ACLOCAL_PATH: {
          type: "append",
          value: { relativePath: "../share/aclocal" },
          separator: ":",
        },
        ACLOCAL_AUTOMAKE_DIR: {
          type: "fallback",
          value: { relativePath: "../share/aclocal-1.16" },
        },
      },
    });

    // Pack all other scripts
    // TODO: Use globs for Perl 5 paths
    toolchain = autopack(toolchain, {
      globs: ["bin/**"],
      selfDependency: true,
      dynamicBinaryConfig: {
        enabled: false,
      },
      sharedLibraryConfig: {
        enabled: false,
      },
      scriptConfig: {
        enabled: true,
        env: {
          PERL5LIB: {
            type: "append",
            value: {
              relativePaths: [
                "lib/perl5/site_perl/5.38.0/x86_64-linux-thread-multi",
                "lib/perl5/site_perl/5.38.0",
                "lib/perl5/5.38.0/x86_64-linux-thread-multi",
                "lib/perl5/5.38.0",
              ],
              separator: ":",
            },
            separator: ":",
          },
        },
      },
    });

    // Re-pack all dynamic binaries. This is done so they reference libraries
    // from the toolchain itself. Note that libraries are not packed, mainly
    // since libc specifically should not be packed.
    toolchain = autopack(toolchain, {
      globs: ["bin/**"],
      selfDependency: true,
      dynamicBinaryConfig: {
        enabled: true,
      },
      sharedLibraryConfig: {
        enabled: false,
      },
      scriptConfig: {
        enabled: false,
      },
      repackConfig: {
        enabled: true,
      },
    });

    // Keep the unpacked version of several wrapper scripts
    const keepUnpackedPaths = [
      "bin/x86_64-pc-linux-gnu-c++",
      "bin/x86_64-pc-linux-gnu-g++",
      "bin/x86_64-pc-linux-gnu-gcc",
      "bin/x86_64-pc-linux-gnu-gcc-13.2.0",
      "bin/c++",
      "bin/g++",
      "bin/gcc",
    ];
    for (const path of keepUnpackedPaths) {
      toolchain = toolchain.insert(path, unpackedToolchain.get(path));
    }

    toolchain = std.sync(toolchain);

    return toolchain;
  },
);

function autopack(
  recipe: std.AsyncRecipe<std.Directory>,
  options: AutopackOptions,
): std.Recipe<std.Directory> {
  const { config, variables } = buildAutopackConfig({
    options,
    defaultLinkDependencies: [],
    runtimeUtils: runtimeUtils(),
  });

  const variableArgs: std.ProcessTemplateLike[] = Object.entries(
    variables,
  ).flatMap(([name, value]) => {
    switch (value.type) {
      case "path":
        return ["--var", std.tpl`${name}=path:${value.value}`];
    }
  });

  return std
    .process({
      command: std.tpl`${runtimeUtils()}/bin/brioche-packer`,
      args: [
        "autopack",
        std.outputPath,
        "--config",
        JSON.stringify(config),
        ...variableArgs,
      ],
      outputScaffold: recipe,
    })
    .toDirectory();
}

interface WithPackedScriptRunnablesOptions {
  paths: string[];
  command: std.ProcessTemplateLike;
  args?: std.ProcessTemplateLike[];
  trailingArgs?: std.ProcessTemplateLike[];
  env?: Record<string, EnvValueConfig>;
  clearEnv?: boolean;
}

function withPackedRunnableScripts(
  recipe: std.AsyncRecipe<std.Directory>,
  options: WithPackedScriptRunnablesOptions,
): std.Recipe<std.Directory> {
  const inputRecipe = std.recipe(recipe);
  const packedScripts: std.Recipe<std.Directory>[] = [];
  for (const path of options.paths) {
    const script = std.tpl`${inputRecipe}/${path}`;
    const args = [
      ...(options.args ?? []),
      script,
      ...(options.trailingArgs ?? []),
    ];
    const { config, resources } = buildPackRunnableConfig({
      command: options.command,
      args,
      env: options.env,
      clearEnv: options.clearEnv,
      source: script,
    });

    const resourceArgs: std.ProcessTemplateLike[] = Object.entries(
      resources,
    ).flatMap(([key, value]) => ["--resource", std.tpl`${key}=${value}`]);

    const runtimeUtilsTesting = std
      .download({
        url: "https://development-content.brioche.dev/github.com/brioche-dev/brioche-runtime-utils/commits/fbd5aceb3bb5322dd88fdb398103306507bd7e61/x86_64-linux/brioche-runtime-utils.tar.zstd",
        hash: std.sha256Hash(
          "59b8594945c4b343edd9256a14b163fe46b8213f9521eebac4f24a2ac628bd0a",
        ),
      })
      .unarchive("tar", "zstd")
      .peel(1);

    const packedScript = std.process({
      command: runtimeUtilsTesting.get("brioche-packer"),
      args: [
        "pack-runnable",
        "--packed",
        std.tpl`${runtimeUtils()}/bin/brioche-packed-plain-exec`,
        "--output",
        std.outputPath,
        ...resourceArgs,
        "--config",
        JSON.stringify(config),
      ],
    });
    packedScripts.push(std.directory({ [path]: packedScript }));
  }

  return std.merge(inputRecipe, ...packedScripts);
}
