import * as std from "std";
import * as TOML from "smol_toml";
import * as t from "typer";
import caCertificates from "ca_certificates";

export const project = {
  name: "rust",
  version: "1.78.0",
};

const ManifestPkgTarget = t.discriminatedUnion("available", [
  t.object({
    available: t.literal(true),
    hash: t.string(),
    url: t.string(),
  }),
  t.object({
    available: t.literal(false),
  }),
]);

const ManifestPkg = t.object({
  target: t.record(t.string(), ManifestPkgTarget),
});

const Manifest = t.object({
  "manifest-version": t.literal("2"),
  pkg: t.record(t.string(), ManifestPkg),
  profiles: t.record(t.string(), t.array(t.string())),
});

async function rust(): Promise<std.Recipe<std.Directory>> {
  const manifestToml = await std
    .download({
      url: "https://static.rust-lang.org/dist/channel-rust-1.78.0.toml",
      hash: std.sha256Hash(
        "a29520b3a7245100b20f1701f56cb9d69aa177430f1875156f044a28f1a2c195",
      ),
    })
    .read();
  const manifest = t.parse(Manifest, TOML.parse(manifestToml));

  // TODO: Support other profiles
  const profilePackages = manifest.profiles.minimal;
  if (profilePackages === undefined) {
    throw new Error("Rustup minimal profile not found");
  }

  let result = std.directory();
  for (const pkgName of profilePackages) {
    const pkg = manifest.pkg[pkgName];
    if (pkg === undefined) {
      throw new Error(`Rustup package ${pkgName} not found`);
    }

    const pkgTarget = pkg.target["x86_64-unknown-linux-gnu"];
    if (pkgTarget?.available !== true) {
      continue;
    }

    // FIXME: We unarchive within the process because unarchiving `rust-docs`
    // fails for some reason
    const pkgTargetArchive = std.download({
      url: pkgTarget.url,
      hash: std.sha256Hash(pkgTarget.hash),
    });

    const installedPkg = std.runBash`
      tar -xf $pkgTargetArchive --strip-components=1
      ./install.sh \\
        --prefix="$BRIOCHE_OUTPUT" \\
        --disable-ldconfig
    `
      .env({ pkgTargetArchive })
      .cast("directory");

    result = std.merge(result, installedPkg);
  }

  const localLibs = await std.runBash`
    find lib -type f -name '*.so' -print0 > "$BRIOCHE_OUTPUT"
  `
    .workDir(result)
    .cast("file")
    .read()
    .then((libs) => libs.split("\0").filter((lib) => lib !== ""));
  const localLibNames = localLibs
    .map((lib) => lib.split("/").at(-1))
    .flatMap((name) => (name != null ? [name] : []));

  result = std.autowrap(result, {
    executables: [
      "bin/cargo",
      "bin/rustc",
      "bin/rustdoc",
      "libexec/rust-analyzer-proc-macro-srv",
    ],
    libraries: [std.tpl`${std.outputPath}/lib`],
    skipLibraries: localLibNames,
    runtimeLibraryDirs: ["../lib"],
  });
  result = std.autowrap(result, {
    executables: ["lib/librustc_driver-d6f66a8619a171d6.so"],
    libraries: [std.tpl`${std.outputPath}/lib`],
  });
  return result;
}
export default rust;

export interface CargoBuildOptions {
  crate: std.AsyncRecipe<std.Directory>;
  toolchain?: std.AsyncRecipe<std.Directory>;
  profile?: string;
  runnable?: string;
}

export function cargoBuild(options: CargoBuildOptions) {
  const toolchain = options.toolchain ?? std.toolchain();

  // Create a skeleton crate so we have enough information to vendor the
  // dependencies
  const skeletonCrate = createSkeletonCrate(options.crate);

  // Vendor the dependencies with network access and save the Cargo config.toml
  // file, so the vendored dependencies are used
  const vendoredSkeletonCrate = std.runBash`
    cd "$BRIOCHE_OUTPUT"
    mkdir -p .cargo
    cargo vendor --locked >> .cargo/config.toml
  `
    .dependencies(rust(), caCertificates())
    .outputScaffold(skeletonCrate)
    .unsafe({ networking: true })
    .cast("directory");

  // Combine the original crate with the vendored dependencies
  const crate = std.merge(vendoredSkeletonCrate, options.crate);

  // Use `cargo install` to build and install the project to `$BRIOCHE_OUTPUT`
  let buildResult = std.runBash`
    cargo install --path . --frozen
  `
    .dependencies(rust(), toolchain)
    .env({
      CARGO_INSTALL_ROOT: std.outputPath,
      PATH: std.tpl`${std.outputPath}/bin`,
    })
    .workDir(crate)
    .cast("directory");

  // Add a runnable link if set in the options
  if (options.runnable != null) {
    buildResult = std.withRunnableLink(buildResult, options.runnable);
  }

  return buildResult;
}

/**
 * Create a "skeleton crate" for a Rust crate. This is a crate that has
 * the minimal set of files needed for Cargo to consider it a valid crate,
 * namely so we can vendor dependencies. Without doing this, we would need
 * to re-vendor the crates any time the source code changes!
 */
export function createSkeletonCrate(
  crate: std.AsyncRecipe<std.Directory>,
): std.Recipe<std.Directory> {
  const recipe = std.runBash`
    cargo chef prepare --recipe-path "$BRIOCHE_OUTPUT"
  `
    .dependencies(rust(), cargoChef())
    .workDir(crate)
    .cast("file");
  return std.runBash`
    cd "$BRIOCHE_OUTPUT"
    cargo chef cook --recipe-path "$recipe" --no-build
  `
    .dependencies(rust(), cargoChef())
    .env({ recipe })
    .outputScaffold(std.directory())
    .cast("directory");
}

function cargoChef(): std.Recipe<std.Directory> {
  const pkg = std.download({
    url: "https://github.com/LukeMathWalker/cargo-chef/releases/download/v0.1.67/cargo-chef-x86_64-unknown-linux-musl.tar.gz",
    hash: std.sha256Hash(
      "91b518df5c8b02775026875f3aadef1946464354db1ca0758e4912249578f0bc",
    ),
  });

  return std.directory({
    bin: pkg.unarchive("tar", "gzip"),
  });
}
